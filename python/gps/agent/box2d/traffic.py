#!/usr/bin/env python
 
import math
import numpy as np
import cPickle as pickle
import pyproj
from scipy.spatial import KDTree, minkowski_distance

STK = [1.339549, 103.712311]   # lat long
SAME_POINT_THRESHOLD = 1e-3    # threshold for distance between points for it to be considered a meeting point between roads

class Traffic(object):

    def __init__(self):

        self.cvtr = SVY21()
        self.ll2utm = pyproj.Proj(proj='utm', zone=48, ellps='WGS84')

        try:
            with open('/media/sunardi/5c4c121b-5f45-4689-b8c3-f44b3e5ef4da/ruihan/gps/python/gps/maps/roads2.pkl', 'rb') as fp:
                self.roads = pickle.load(fp)
                print("successfully load the road")
            # with open('maps/lanes.p', 'rb') as fp:
            #     self.lanes = pickle.load(fp)
            # with open('maps/tlights.p', 'rb') as fp:
            #     self.tlights = pickle.load(fp)
            # with open('maps/tsigns.p', 'rb') as fp:
            #     self.tsigns = pickle.load(fp)
        # except FileNotFoundError:
        except IOError as e:
            print('Pickle files not found.')
            print('Please initialize by running traffic main file.')
            return

        def create_tree(lines):
            idxs = []
            points = []
            for i in range(len(lines)):
                for j in range(len(lines[i])):
                    idxs.append((i,j))
                    points.append((lines[i][j][0], lines[i][j][1]))
            tree = KDTree(points)
            tree.idxs = idxs
            return tree
    
        self.roads_tree = create_tree(self.roads)
        # self.lanes_tree = create_tree(self.lanes)
        # self.tlights_tree = KDTree(self.tlights)

        # TODO use hough transform to store lanes and roads data so that which lanes correspond to the same road can be found

    def randomRoute(self, dist=1000, np_random=None):
        # pick random road as center and pick goal a certain distance away
        if np_random is None: np_random = np.random.RandomState()

        # keep looping until full route found
        while True:
            idx = np_random.randint(self.roads_tree.n)
            if self.roads_tree.idxs[idx][1] == 0: idx_dir = +1
            elif idx+1 == self.roads_tree.n or self.roads_tree.idxs[idx+1][1] == 0: idx_dir = -1
            else: idx_dir = np_random.choice([-1,+1])

            route = [ self.roads_tree.data[idx].copy() ]
            route_idxs = [ idx ]
            route_dist = 0            
            while route_dist < dist:
                if idx+idx_dir >= 0 and idx+idx_dir < self.roads_tree.n and self.roads_tree.idxs[idx+idx_dir][0] == self.roads_tree.idxs[idx][0]:
                    next_idx = idx + idx_dir
                    dist_to_next = minkowski_distance(self.roads_tree.data[idx],self.roads_tree.data[next_idx])
                else:
                    neighbors = self.roads_tree.query(self.roads_tree.data[idx],k=4)
                    intersect = list(np.where(neighbors[0]<=SAME_POINT_THRESHOLD,1,0))
                    idxs = list(neighbors[1])
                    removes = [idx_ for idx_, intersect_ in zip(idxs,intersect) if intersect_ == 0 or idx_ == idx or idx_ in route_idxs]
                    for i in removes: idxs.remove(i)
                    if len(idxs) == 0: route_dist = -1
                    else:
                        next_idx = np_random.choice(idxs)
                        i = list(neighbors[1]).index(next_idx)
                        dist_to_next = neighbors[0][i]
                        if self.roads_tree.idxs[next_idx][1] == 0: idx_dir = +1
                        elif next_idx+1 == self.roads_tree.n or self.roads_tree.idxs[next_idx+1][1] == 0: idx_dir = -1
                        else: idx_dir = np.random.choice([-1,+1])

                if route_dist < 0: break
                route.append(self.roads_tree.data[next_idx].copy())
                route_idxs.append(next_idx)
                route_dist += dist_to_next
                idx = next_idx
            
            if route_dist < 0: continue
            else: break
        
        roads_idxs = []
        self.cropped_roads = []
        for idx in route_idxs:
            road_no = self.roads_tree.idxs[idx][0]
            if road_no not in roads_idxs:
                roads_idxs.append( road_no )
                self.cropped_roads.append(self.roads[road_no])

        # print("route generated by randomRoute")
        # print(route)
        return route


    def cropMap(self, center=None, radius=500):
        
        if center is None:
            center = STK
            self.center_ll = (center[0], center[1])
            self.center_svy = self.cvtr.computeSVY21(center[0], center[1])
            self.center_utm = self.ll2utm(center[1], center[0])
        else:
            self.center_utm = center

        cropped_roads_idxs = self.roads_tree.query_ball_point(self.center_utm, 2*radius, p=1)
        self.cropped_roads = []
        roads_idxs = []
        for idx in cropped_roads_idxs:
            road_no = self.roads_tree.idxs[idx][0]
            if road_no not in roads_idxs:
                roads_idxs.append( road_no )
                self.cropped_roads.append(self.roads[road_no])

        # self.cropped_lanes = self.lanes_tree.query_ball_point(self.center_utm, radius)
        # self.cropped_tlights = self.tlights_tree.query_ball_point(self.center_utm, radius)
        
    def loadShapes(self):

        self.tlights_shp = 'maps/GEOSPATIAL/TrafficLight_May2017/TrafficSignalAspect.shp'
        self.tsigns_shp = 'maps/GEOSPATIAL/TrafficSign_May2017/TrafficSign.shp'
        self.lanes_shp ='maps/GEOSPATIAL/LaneMarking_May2017/LaneMarking.shp'
        self.footpath_shp ='maps/GEOSPATIAL/Footpath_May2017/Footpath.shp'
        self.roads_shp = 'maps/GEOSPATIAL/RoadSectionLine_May2017/RoadSectionLine.shp'

        print("......loading.......")

        self.tlights = self.loadPoints(self.tlights_shp)
        with open('maps/tlights.p', 'wb') as fp:
            pickle.dump(self.tlights, fp)

        self.tsigns = self.loadPoints(self.tsigns_shp)
        with open('maps/tsigns.p', 'wb') as fp:
                pickle.dump(self.tsigns, fp)

        self.lanes = self.loadLines(self.lanes_shp)
        self.lanes = self.lanes + self.loadLines(self.footpath_shp)
        with open('maps/lanes.p', 'wb') as fp:
                pickle.dump(self.lanes, fp)

        self.roads = self.loadLines(self.roads_shp)
        with open('maps/roads.p', 'wb') as fp:
            pickle.dump(self.roads, fp)

        print("......initialized.......")

    def loadLines(self, shapefile):
        source_ds = ogr.Open(shapefile)
        layer = source_ds.GetLayer()
        lines_utm = []
        feat = layer.GetNextFeature()
        while feat is not None:
            geom = feat.GetGeometryRef()
            if geom is None:
                feat = layer.GetNextFeature()
                continue
            if geom.GetGeometryName() == 'LINESTRING':
                points = geom.GetPoints()
            elif geom.GetGeometryName() == 'MULTILINESTRING':
                points = []
                for line in geom:
                    points.extend(line.GetPoints())
            points_utm = []
            for point in points:
                E = float(point[0])
                N = float(point[1])
                points_utm.append(self.svy2utm((E,N)))
            lines_utm.append(points_utm)
            feat = layer.GetNextFeature()
        return lines_utm
    
    def loadPoints(self, shapefile):
        source_ds = ogr.Open(shapefile)
        layer = source_ds.GetLayer()
        points_utm = []
        feat = layer.GetNextFeature()
        while feat is not None:
            geom = feat.GetGeometryRef()
            if geom is None:
                feat = layer.GetNextFeature()
                break
            E = float(geom.GetPoint()[0])
            N = float(geom.GetPoint()[1])
            points_utm.append(self.svy2utm((E, N)))
            feat = layer.GetNextFeature()
        return points_utm

    def svy2utm(self, EN):
        lat, lon = self.cvtr.computeLatLon(EN[1], EN[0])
        x,y = self.ll2utm(lon, lat)
        return [x, y]


class SVY21:
    # Ref: http://www.linz.govt.nz/geodetic/conversion-coordinates/projection-conversions/transverse-mercator-preliminary-computations/index.aspx
    
    # WGS84 Datum
    a = 6378137
    f = 1 / 298.257223563

    # SVY21 Projection
    # Fundamental point: Base 7 at Pierce Resevoir.
    # Latitude: 1 22 02.9154 N, longitude: 103 49 31.9752 E (of Greenwich).

    # Known Issue: Setting (oLat, oLon) to the exact coordinates specified above
    # results in computation being slightly off. The values below give the most 
    # accurate represenation of test data.
    oLat = 1.366666     # origin's lat in degrees
    oLon = 103.833333   # origin's lon in degrees
    oN = 38744.572      # false Northing
    oE = 28001.642      # false Easting
    k = 1               # scale factor

    #
    def __init__(self):
        self.b = self.a * (1 - self.f)
        self.e2 = (2 * self.f) - (self.f * self.f)
        self.e4 = self.e2 * self.e2
        self.e6 = self.e4 * self.e2
        self.A0 = 1 - (self.e2 / 4) - (3 * self.e4 / 64) - (5 * self.e6 / 256);
        self.A2 = (3. / 8.) * (self.e2 + (self.e4 / 4) + (15 * self.e6 / 128));
        self.A4 = (15. / 256.) * (self.e4 + (3 * self.e6 / 4));
        self.A6 = 35 * self.e6 / 3072;

    def computeSVY21(self, lat, lon):
        """
        Returns a pair (N, E) representing Northings and Eastings in SVY21.
        """

        latR = lat * math.pi / 180
        sinLat = math.sin(latR)
        sin2Lat = sinLat * sinLat
        cosLat = math.cos(latR)
        cos2Lat = cosLat * cosLat
        cos3Lat = cos2Lat * cosLat
        cos4Lat = cos3Lat * cosLat
        cos5Lat = cos4Lat * cosLat
        cos6Lat = cos5Lat * cosLat
        cos7Lat = cos6Lat * cosLat

        rho = self.calcRho(sin2Lat)
        v = self.calcV(sin2Lat)
        psi = v / rho
        t = math.tan(latR)
        w = (lon - self.oLon) * math.pi / 180

        M = self.calcM(lat)
        Mo = self.calcM(self.oLat)

        w2 = w * w
        w4 = w2 * w2
        w6 = w4 * w2
        w8 = w6 * w2

        psi2 = psi * psi
        psi3 = psi2 * psi
        psi4 = psi3 * psi

        t2 = t * t
        t4 = t2 * t2
        t6 = t4 * t2

        # Compute Northing
        nTerm1 = w2 / 2 * v * sinLat * cosLat
        nTerm2 = w4 / 24 * v * sinLat * cos3Lat * (4 * psi2 + psi - t2)
        nTerm3 = w6 / 720 * v * sinLat * cos5Lat * ((8 * psi4) * (11 - 24 * t2) - (28 * psi3) * (1 - 6 * t2) + psi2 * (1 - 32 * t2) - psi * 2 * t2 + t4)
        nTerm4 = w8 / 40320 * v * sinLat * cos7Lat * (1385 - 3111 * t2 + 543 * t4 - t6)
        N = self.oN + self.k * (M - Mo + nTerm1 + nTerm2 + nTerm3 + nTerm4)

        # Compute Easting
        eTerm1 = w2 / 6 * cos2Lat * (psi - t2)
        eTerm2 = w4 / 120 * cos4Lat * ((4 * psi3) * (1 - 6 * t2) + psi2 * (1 + 8 * t2) - psi * 2 * t2 + t4)
        eTerm3 = w6 / 5040 * cos6Lat * (61 - 479 * t2 + 179 * t4 - t6)
        E = self.oE + self.k * v * w * cosLat * (1 + eTerm1 + eTerm2 + eTerm3)

        return (N, E)

    def calcM(self, lat):
        latR = lat * math.pi / 180
        return self.a * ((self.A0 * latR) - (self.A2 * math.sin(2 * latR)) + (self.A4 * math.sin(4 * latR)) - (self.A6 * math.sin(6 * latR)))

    def calcRho(self, sin2Lat):
        num = self.a * (1 - self.e2)
        denom = math.pow(1 - self.e2 * sin2Lat, 3. / 2.)
        return num / denom

    def calcV(self, sin2Lat):
        poly = 1 - self.e2 * sin2Lat
        return self.a / math.sqrt(poly)

    def computeLatLon(self, N, E):
        """
        Returns a pair (lat, lon) representing Latitude and Longitude.
        """

        Nprime = N - self.oN
        Mo = self.calcM(self.oLat)
        Mprime = Mo + (Nprime / self.k)
        n = (self.a - self.b) / (self.a + self.b)
        n2 = n * n
        n3 = n2 * n
        n4 = n2 * n2
        G = self.a * (1 - n) * (1 - n2) * (1 + (9 * n2 / 4) + (225 * n4 / 64)) * (math.pi / 180)
        sigma = (Mprime * math.pi) / (180. * G)
        
        latPrimeT1 = ((3 * n / 2) - (27 * n3 / 32)) * math.sin(2 * sigma)
        latPrimeT2 = ((21 * n2 / 16) - (55 * n4 / 32)) * math.sin(4 * sigma)
        latPrimeT3 = (151 * n3 / 96) * math.sin(6 * sigma)
        latPrimeT4 = (1097 * n4 / 512) * math.sin(8 * sigma)
        latPrime = sigma + latPrimeT1 + latPrimeT2 + latPrimeT3 + latPrimeT4

        sinLatPrime = math.sin(latPrime)
        sin2LatPrime = sinLatPrime * sinLatPrime

        rhoPrime = self.calcRho(sin2LatPrime)
        vPrime = self.calcV(sin2LatPrime)
        psiPrime = vPrime / rhoPrime
        psiPrime2 = psiPrime * psiPrime
        psiPrime3 = psiPrime2 * psiPrime
        psiPrime4 = psiPrime3 * psiPrime
        tPrime = math.tan(latPrime)
        tPrime2 = tPrime * tPrime
        tPrime4 = tPrime2 * tPrime2
        tPrime6 = tPrime4 * tPrime2
        Eprime = E - self.oE
        x = Eprime / (self.k * vPrime)
        x2 = x * x
        x3 = x2 * x
        x5 = x3 * x2
        x7 = x5 * x2

        # Compute Latitude
        latFactor = tPrime / (self.k * rhoPrime)
        latTerm1 = latFactor * ((Eprime * x) / 2)
        latTerm2 = latFactor * ((Eprime * x3) / 24) * ((-4 * psiPrime2) + (9 * psiPrime) * (1 - tPrime2) + (12 * tPrime2))
        latTerm3 = latFactor * ((Eprime * x5) / 720) * ((8 * psiPrime4) * (11 - 24 * tPrime2) - (12 * psiPrime3) * (21 - 71 * tPrime2) + (15 * psiPrime2) * (15 - 98 * tPrime2 + 15 * tPrime4) + (180 * psiPrime) * (5 * tPrime2 - 3 * tPrime4) + 360 * tPrime4)
        latTerm4 = latFactor * ((Eprime * x7) / 40320) * (1385 - 3633 * tPrime2 + 4095 * tPrime4 + 1575 * tPrime6)
        lat = latPrime - latTerm1 + latTerm2 - latTerm3 + latTerm4

        # Compute Longitude
        secLatPrime = 1. / math.cos(lat)
        lonTerm1 = x * secLatPrime
        lonTerm2 = ((x3 * secLatPrime) / 6) * (psiPrime + 2 * tPrime2)
        lonTerm3 = ((x5 * secLatPrime) / 120) * ((-4 * psiPrime3) * (1 - 6 * tPrime2) + psiPrime2 * (9 - 68 * tPrime2) + 72 * psiPrime * tPrime2 + 24 * tPrime4)
        lonTerm4 = ((x7 * secLatPrime) / 5040) * (61 + 662 * tPrime2 + 1320 * tPrime4 + 720 * tPrime6)
        lon = (self.oLon * math.pi / 180) + lonTerm1 - lonTerm2 + lonTerm3 - lonTerm4

        return (lat / (math.pi / 180), lon / (math.pi / 180))

if __name__ == '__main__':
    import gdal
    from osgeo import ogr

    traffic = Traffic()
    print('Running traffic main file.')
    traffic.loadShapes()